\chapter{Implementation}
\label{implementation}
This project is intended to be treated as a tool box for the optimization of acoustic networks.  While a fully-functional application is provided, its intent is to serve as a template for integrating various functions.  It is expected that researchers will want to define and use customized versions of the provided functions (herein referred to as ''subfunctions'').  To support this, the framework utilizes generic ''dispatcher functions'' and dictionary-based parameter passing.  

\subsection{Parameter Dictionary}
\label{parameterDictionary}
The framework takes as an input to the main program a dictionary of named values, and passes this dictionary throughout the program.  This allows for dispatcher functions with concrete function signatures (including the parameter dictionary), and sub-functions with widely varied signatures.  The benefit of this is that the function signatures of the dispatcher functions will rarely need to be changed, leading to a stable but flexible framework. The cost of this approach is of course that substantial data validation must be preformed by the program before the execution of sub-functions in order to avoid run-time errors within the varied sub-functions.  


\subsection{Sub-Functions}
\label{sub-functions}
Section \ref{design} discusses the framework's conceptual models such as Goodness computation and animal modeling.  These models have loose operational requirements that can be thought of as roles.  For example, it is expected that an animal model populates the Behavior Grid, and that an Evaluation Algorithm populate the Goodness Grid.  As long as a user-customized sub-function fulfills its role within the prescribed model (suppressing a given location, populating a Grid, etc.), it can be easily integrated into the framework.

\subsection{Dispatcher Functions}
\label{dispatcherFunctions}
The primary purpose of dispatcher functions is to create a uniform interface within the framework for calling various sub-functions.  Each model has a corresponding dispatcher function, and these dispatcher functions are responsible for preparing and calling sub-functions which belong to that model.  E.g. The Animal Model dispatcher is responsible for functions which populate the Behavior Grid.  A dispatcher function simply performs a series of if-else checks over one or more ''check variables'' in the parameter dictionary, and fires the corresponding code snippet or sub-function.  Once a user defines a new sub-function, they should add a check statement (over the dispatcher's check variable) within the corresponding dispatcher that calls the new sub-function.  This will allow a user to use the new sub-function by simply changing the value of the dispatcher's check variable.  Any sub-function specific data validation should be done within the \texttt{checkParams()} function (Section~\ref{checkParams}), which validates data at the beginning of the program before any computationally-expensive operations are preformed.


\subsection{Major Modules}
\label{majorModules}
\subsubsection{Parameter Checking}
\label{checkParams}
As previously mentioned in Section~\ref{parameterDictionary}, the cost of flexible inputs is substantial data validation.  Within our framework, data validation should occur early on so that errors can be identified before too much time has been invested in computation or data-loading.  To this end, the \texttt{checkParams()} function is provided to handle all data validation and reporting.  The function takes in the \texttt{params} parameter dictionary and a \texttt{stop} boolean (set to True by default).  The function and validates all internal dependencies, reporting any errors found, and halting the program if \texttt{stop} is True.  The function also assigns necessary default values if no user-defined values are provided.  The function returns the validated \texttt{params} parameter dictionary (with default values if necessary).  

\subsubsection{File Output}
Graphic and text outputs are handled by the \texttt{graph()} function. \texttt{graph()} requires a \texttt{result} parameter dictionary, containing the key-value pairs described in Table~\ref{resultDict}.  This dictionary contains the results from successfully running the simulation, and finding optimal receiver locations.  The \texttt{result} dictionary is separate from the \texttt{params} dictionary as the values in the Bathymetry, Behavior, and Goodness Grids may have been modified by Suppression.  Filenames for output files are given by \texttt{timestamp-FileName.extension}, where \texttt{timestamp} is a user-specified string (defaulting to the time the request passed Parameter Validation), \texttt{FileName} is a contextual identifier (''GoodnessGrid'', ''BehaviorGrid'', etc), and \texttt{extension} is either \texttt{.png} for a a graphic, \texttt{.zip} for a zip archive, or \texttt{.txt} for a text file.  The \texttt{graph()} function takes in four parameters, the \texttt{result} and \texttt{params} dictionaries, \texttt{plot.bathy} (a boolean, set to True by default, indicating whether or not bathymetric contour lines should be drawn on Grid graphs), writes the output files described in Section~\ref{outputFiles}, and returns a dictionary of file paths that point to the the newly written files.

\begin{table}[ht]
	\begin{tabular}{l l l}
		Key	&	Value &	Description\\
		\hline
		\texttt{topographyGrid}	&	The Bathymetry Grid			&	An alias for the unmodified Bathymetry Grid.\\
		\texttt{behaviorGrid}	&	The Behavior Grid			&	The unmodified Behavior Grid.\\
		\texttt{goodnessGrid}	&	The Goodness Grid			&	The unmodified Goodness Grid.\\
		\texttt{coverageGrid}	& 	The Coverage Grid			&	The coverage computed from the resulting\\
								&								&	receiver array.\\
		\texttt{recoveryRates}	& 	Receiver array data			&	A dictionary of receiver array-related results\\
								&								&  obtained as an output from the simulation. \\
								&								&  The dictionary is generated by \texttt{sensorFun()}.\\
		\texttt{stats}			& 	Receiver array statistics	&	A dictionary of receiver array-related statistics\\
								&								&  obtained from calling getStats().\\
	\end{tabular}
	\caption{A summary of the key-value pairs in the \texttt{result} dictionary.
		\label{resultDict}}
\end{table}


\subsubsection{Bathymetry Parsing}
The parsing, loading, and validation of bathymetric data is handled by the \texttt{getBathy()} function, which requires a \texttt{params} parameter dictionary containing the key-value pairs described in Table~\ref{bathyParams}.  The function returns a validated Bathymetry Grid of \texttt{XDist} columns and \texttt{YDist} rows.  As previously mentioned in Section~\ref{bathymetricFiletypes}, there are a multitude of data formats for bathymetric data, each requiring a unique data parser.  To support this diversity, the \texttt{getBathy()} function reads the \texttt{inputFileType} from the \texttt{params} dictionary to select an appropriate parser.  The selected parser begins reading data at column \texttt{startX} and row \texttt{startY} from the data file specified by \texttt{inputFile}.  The \texttt{getBathy()} function also checks to makes sure that all cells in the Bathymetry Grid have rational depth values.  N/A, INF, or -INF values are invalid as they will contaminate future computations, resulting in runtime errors.  The module replaces invalid values with a value of '0'.  By default, the framework supports the NetCDF type, and thus requires the ''ncdf'' or ''ncdf4'' R packages.  The ''ncdf'' package serves as an R interface for the NetCDF C/FORTRAN library, and thus requires that a working NetCDF distribution be installed on the system.  The ''ncdf4'' package interacts directly with NetCDF files, and thus does not require a working NetCDF distribution.  

\begin{table}[ht]
	\begin{tabular}{l l l}
		Key						&	Value 								&	Description\\
		\hline
		\texttt{inputFile}		& 	File path to Bathymetry File.		&	A relative or absolute Bathymetry File\\
								&										&	path.\\
		\texttt{inputFileType}	& 	Parser name.						&	Indicates which parser to use to read the \\
								&										&	Bathymetry File.\\
		\texttt{XDist}			&	Bathymetry Grid col count.			&	Number of columns in the Behavior Grid.\\
		\texttt{YDist}			&	Bathymetry Grid row count.			&	Number of rows in the Behavior 	Grid.\\		
		\texttt{startX}			& 	Col index to read from. 			& 	The column index in the Bathymetry\\
								&										&   File to	begin reading from.\\
		\texttt{startY}			& 	Row index to read from.				&	The row index in the Bathymetry\\
								&										&	File to begin reading from.\\
	\end{tabular}
	\caption{A summary of the \texttt{params} key-value pairs used in Bathymetry Parsing module .
		\label{bathyParams}}
\end{table}

\subsubsection{Animal Modeling}
The Animal Modeling module is responsible for populating the Behavior Grid (which has the same dimensions as the Bathymetry Grid).  As mentioned in Section~\ref{animalModeling}, the Animal Model offers separate horizontal and vertical movement models.  The animal movement models are handled by the \texttt{fish()} function, which requires a \texttt{params} parameter dictionary.  The \texttt{fishModel} dictionary key specifies which horizontal movement model should be employed by the module to generate a population distribution.  Because the vertical movement models operate independently of the horizontal movement model and each other, we provide separate keys for both vertical movement models.  The Restricted Vertical Habitat Range model is used if two keys, (\texttt{mindepth} and \texttt{maxdepth}), are specified within the \texttt{params} dictionary.  Similarly, the Habitat Preference model is used if \texttt{depth\_off\_bottom} and \texttt{depth\_off\_bottom\_sd} keys are present within the \texttt{params} dictionary.

\begin{table}[ht]
	\begin{tabular}{l l l}
		Key									&	Value 							&	Description\\
		\hline
		\texttt{fishModel}					& 	Behavior Model Name.			&	The chosen Horizontal Behavioral\\
					 						&									&    Model.\\
		\texttt{Behavior Grid}				&	The Behavior Grid.				&	The resulting Behavior Grid.\\
		\texttt{mindepth}*					& 	Min depth for animal habitat.	&	Minimum depth in the Restricted\\
					 						&									&   Vertical Habitat Range Model.\\
		\texttt{maxdepth}*					& 	Max depth for animal habitat.	&	Maximum depth in the Restricted\\
					 						&									&   Vertical Habitat Range Model.\\
		\texttt{depth\_off\_bottom}*		& 	Preferred animal habitat depth.	&   Preferred depth in the Habitat\\
					 						&									&   Preference Model.\\
		\texttt{depth\_off\_bottom\_sd}*	& 	SD of preferred depth.			&   Standard Deviation of preferred\\
					 						&									&   depth in the Habitat Preference Model.\\
	\end{tabular}
	\caption{A summary of the \texttt{params} key-value pairs used in Animal Modeling module.  \newline * optional parameters.
		\label{animalParams}}
\end{table}

\subsubsection{Goodness Computation}
Goodness Computation is handled by the \texttt{goodnessGridFun()}, which takes in \texttt{params}, a parameter dictionary and \texttt{grids}, a parameter dictionary containing the Bathymetry Grid, and Behavior Grid.  The \texttt{bias} key is used to tell the module which sub-function should be used to compute Goodness.  The module will then simply populate the Goodness Grid according to the chosen sub-function.  The populated GoodnessGrid is then inserted into the $grids$ parameter dictionary.  Because the Goodness computation can take a substantial amount of time, the sub-functions should provide textual output to signify what percentage of the Grid has been computed.  The \texttt{silent} parameter is a boolean that enables this output if set to True.  A \texttt{debug} boolean is also available to toggle debug printing.

\subsubsection{Suppression}
sensorFun.suppressHelper = function(loc, grids, range, bias, params, debug=FALSE, multi=FALSE) {

custom main
acousticRun <- function(params, showPlots=FALSE, debug=FALSE, save.inter=FALSE, silent=FALSE, multi=FALSE) {

custom test
acousticTest <- function(bias=3, real=FALSE, exact=FALSE, multi=FALSE, showPlots=FALSE, paper=FALSE, silent=FALSE, debug=FALSE) {
	Executes a test run of the program, using default parameters.  No additional 
	parameters are necessary. The code for this function can be used as a template for new projects.


* Intended to be used as a loose R framework, where users define new sub functions and add them to the dispatcher functions.
* dispatcher functions
* Provided implementation is very simple.
* parameters are very loose, allowing for easy implementation. makes it more flexible but less neat and concise and error prone.

\subsubsection{Web Server}
Included alongside the framework is a web-application (webapp) with a Graphical User Interface (GUI) that runs a simple demonstrative application of the framework.  The webapp utilizes the $Rook$ R package, which allows the display of static content and the handling of HTTP requests/responses.  The GUI is a simple HTML page that generates a list of parameters (including a unique $timestamp$ identifier) based on user input, and creates a JSON (JavaScript Object Notation) string, and sends an HTTP request to the Rook server with that string.  Using the $rjson$ library, the Rook server receives the GUI's request, decodes the JSON string into R data objects, and calls the demo application using the translated parameters.  The Rook application signals the successful reception of parameters to the user as an HTTP 200 status update.  The GUI then begins waiting for the completion of the simulation (which may take some time) by continuously checking (ignoring failures) for the existence of a text document (named for the unique $timestamp$ identifier) on the server.  When the simulation finishes its execution (either via error or normal completion), it writes its several output files (Section~\ref{outputFiles}), and a text document containing the JSON representation of the outputs (file paths to graphics and a dictionary of results).  All output files are tagged with a unique $timestamp$ identifier.  Once the GUI finds an output file with the correct $timestamp$ signature, it reads the file, parses the results, and displays them as a web page.  If the local system supports it, a zip file of all result files is also supplied for download.  


Implementation Hurdles
arcGIS rgdal - arcgis has a butt load of file formats and encoding schemes.  Not easy to support them all.  
Netcdf - old version required fortran library and in some cases compiler pre-installed.  ncdf4 fixes that.
rook didnt have template support, had to hand write lots of stuff using jquery load
rook is single threaded; blocks real-time updates.
rook has max packet size, had to split packets up and recombine on server side.
