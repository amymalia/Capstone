\chapter{Implementation}
\label{implementation}
This project is intended to be treated as a tool box for the optimization of acoustic networks.  While a fully-functional application is provided, its intent is to serve as a template for integrating various functions.  It is expected that researchers will want to define and use customized versions of the provided functions (herein referred to as ''subfunctions'').  To support this, the framework utilizes generic ''dispatcher functions'' and dictionary-based parameter passing.  

\subsection{Parameter Dictionary}
\label{parameterDictionary}
The framework takes as an input to the main program a dictionary of named values, and passes this dictionary throughout the program.  This allows for dispatcher functions with concrete function signatures (including the parameter dictionary), and sub-functions with widely varied signatures.  The benefit of this is that the function signatures of the dispatcher functions will rarely need to be changed, leading to a stable but flexible framework. The cost of this approach is of course that substantial data validation must be preformed by the program before the execution of sub-functions in order to avoid run-time errors within the varied sub-functions.  


\subsection{Sub-Functions}
\label{sub-functions}
Section \ref{design} discusses the framework's conceptual models such as Goodness computation and animal modeling.  These models have loose operational requirements that can be thought of as roles.  For example, it is expected that an animal model populates the Behavior Grid, and that an Evaluation Algorithm populate the Goodness Grid.  As long as a user-customized sub-function fulfills its role within the prescribed model (suppressing a given location, populating a Grid, etc.), it can be easily integrated into the framework.

\subsection{Dispatcher Functions}
\label{dispatcherFunctions}
The primary purpose of dispatcher functions is to create a uniform interface within the framework for calling various sub-functions.  Each model has a corresponding dispatcher function, and these dispatcher functions are responsible for preparing and calling sub-functions which belong to that model.  E.g. The Animal Model dispatcher is responsible for functions which populate the Behavior Grid.  A dispatcher function simply performs a series of if-else checks over one or more ''check variables'' in the parameter dictionary, and fires the corresponding code snippet or sub-function.  Once a user defines a new sub-function, they should add a check statement (over the dispatcher's check variable) within the corresponding dispatcher that calls the new sub-function.  This will allow a user to use the new sub-function by simply changing the value of the dispatcher's check variable.  Any sub-function specific data validation should be done at the beginning of the program, before any computationally-expensive operations are preformed, by the \texttt{checkParams()} function (Section~\ref{checkParams}).


\subsection{Major Modules}
\label{majorModules}
\subsubsection{Parameter Checking}
\label{checkParams}
As previously mentioned in Section~\ref{parameterDictionary}, the cost of flexible inputs is substantial data validation.  Within our framework, data validation should occur early on so that errors can be identified before too much time has been invested in computation or data-loading.  To this end, the \texttt{checkParams()} function is provided to handle all data validation and reporting.  The function takes in the \texttt{params} parameter dictionary and a \texttt{stop} boolean (set to True by default).  The function and validates all internal dependencies, reporting any errors found, and halting the program if \texttt{stop} is True.  The function also assigns necessary default values if no user-defined values are provided.  The function returns the validated \texttt{params} parameter dictionary (with default values if necessary).  

\subsubsection{File Output}
Graphic and text outputs are handled by the \texttt{graph()} function. \texttt{graph()} requires a \texttt{result} parameter dictionary, containing the key-value pairs described in Table~\ref{resultDict}.  This dictionary contains the results from successfully running the simulation, and finding optimal receiver locations.  The \texttt{result} dictionary is separate from the \texttt{params} dictionary as the values in the Bathymetry, Behavior, and Goodness Grids may have been modified by Suppression.  Filenames for output files are given by \texttt{timestamp-FileName.extension}, where \texttt{timestamp} is a user-specified string (defaulting to the time the request passed Parameter Validation), \texttt{FileName} is a contextual identifier (''GoodnessGrid'', ''BehaviorGrid'', etc), and \texttt{extension} is either \texttt{.png} for a a graphic, \texttt{.zip} for a zip archive, or \texttt{.txt} for a text file.  The \texttt{graph()} function takes in four parameters, the \texttt{result} and \texttt{params} dictionaries, \texttt{plot.bathy} (a boolean, set to True by default, indicating whether or not bathymetric contour lines should be drawn on Grid graphs), writes the output files described in Section~\ref{outputFiles}, and returns a dictionary of file paths that point to the the newly written files.

\begin{table}[ht]
	\begin{tabular}{l l l}
		Key	&	Value &	Description\\
		\hline
		\texttt{topographyGrid}	&	The Bathymetry Grid			&	An alias for the unmodified Bathymetry Grid.\\
		\texttt{behaviorGrid}	&	The Behavior Grid			&	The unmodified Behavior Grid.\\
		\texttt{goodnessGrid}	&	The Goodness Grid			&	The unmodified Goodness Grid.\\
		\texttt{coverageGrid}	& 	The Coverage Grid			&	The coverage computed from the resulting\\
								&								&	receiver array.\\
		\texttt{recoveryRates}	& 	Receiver array data			&	A dictionary of receiver array-related results\\
								&								&  obtained as an output from the simulation. \\
								&								&  The dictionary is generated by \texttt{sensorFun()}.\\
		\texttt{stats}			& 	Receiver array statistics	&	A dictionary of receiver array-related statistics\\
								&								&  obtained from calling getStats().\\
	\end{tabular}
	\caption{A summary of the key-value pairs in the \texttt{result} dictionary.
		\label{resultDict}}
\end{table}


\subsubsection{Bathymetry Parsing}
getBathy = function(params, debug=FALSE) 
The parsing, loading, and validation of bathymetric data is handled by the \texttt{getBathy()} function, which requires a \texttt{params} parameter dictionary containing the key-value pairs described in Table~\ref{bathyParams}.  The function returns a validated Bathymetry Grid of \texttt{XDist} columns and \texttt{YDist} rows.  As previously mentioned in Section~\ref{bathymetricFiletypes}, there are a multitude of data formats for bathymetric data, each requiring a unique data parser.  To support this diversity, the \texttt{getBathy()} function reads the \texttt{inputFileType} from the \texttt{params} dictionary to select an appropriate parser.  The selected parser begins reading data at column \texttt{startX} and row \texttt{startY} from the data file specified by \texttt{inputFile}.  The \texttt{getBathy()} function also checks to makes sure that all cells in the Bathymetry Grid have rational depth values.  N/A, INF, or -INF values are invalid as they will contaminate future computations, resulting in runtime errors.  The module replaces invalid values with a value of '0'.  By default, the framework supports the NetCDF type, and thus requires the ''ncdf'' or ''ncdf4'' R packages.  The ''ncdf'' package serves as an R interface for the NetCDF C/FORTRAN library, and thus requires that a working NetCDF distribution be installed on the system.  The ''ncdf4'' package interacts directly with NetCDF files, and thus does not require a working NetCDF distribution.  

\begin{table}[ht]
	\begin{tabular}{l l l}
		Key						&	Value 								&	Description\\
		\hline
		\texttt{inputFile}		& 	File path to Bathymetry File.		&	A relative or absolute Bathymetry File\\
								&										&	path.\\
		\texttt{inputFileType}	& 	Parser name.						&	Indicates which parser to use to read the \\
								&										&	Bathymetry File.\\
		\texttt{XDist}			&	Bathymetry Grid col count.			&	Number of columns in the Behavior Grid.\\
		\texttt{YDist}			&	Bathymetry Grid row count.			&	Number of rows in the Behavior 	Grid.\\		
		\texttt{startX}			& 	Col index to read from. 			& 	The column index in the Bathymetry\\
								&										&   File to	begin reading from.\\
		\texttt{startY}			& 	Row index to read from.				&	The row index in the Bathymetry\\
								&										&	File to begin reading from.\\
	\end{tabular}
	\caption{A summary of the \texttt{params} key-value pairs used in Bathymetry Parsing module .
		\label{bathyParams}}
\end{table}

\subsubsection{Animal Modeling}
fish(params, topographyGrid, debug=FALSE)
	
Animal Modeling is handled by the \texttt{fish} function, which takes in a BathymetryGrid and a \texttt{params} parameter dictionary containing the key-value pairs described in Table~\ref{bathyParams}he Animal Modeling module is responsible for populating the Behavior Grid (which has the same dimensions as the Bathymetry Grid).  

As mentioned in Section~\ref{animalModeling}, the Animal Model offers separate horizontal and vertical movement models.  The animal movement models are handled by the \texttt{fish()} function, which requires a \texttt{params} parameter dictionary.  The \texttt{fishModel} dictionary key specifies which horizontal movement model should be employed by the module to generate a population distribution.  Because the vertical movement models operate independently of the horizontal movement model and each other, we provide separate keys for both vertical movement models.  The Restricted Vertical Habitat Range model is used if two keys, (\texttt{mindepth} and \texttt{maxdepth}), are specified within the \texttt{params} dictionary.  Similarly, the Habitat Preference model is used if \texttt{depth\_off\_bottom} and \texttt{depth\_off\_bottom\_sd} keys are present within the \texttt{params} dictionary.  

\begin{table}[ht]
	\begin{tabular}{l l l}
		Key									&	Value 							&	Description\\
		\hline
		\texttt{fishModel}					& 	Behavior Model Name.			&	The chosen Horizontal Behavioral\\
					 						&									&    Model.\\
		\texttt{mindepth}*					& 	Min depth for animal habitat.	&	Minimum depth in the Restricted\\
					 						&									&   Vertical Habitat Range Model.\\
		\texttt{maxdepth}*					& 	Max depth for animal habitat.	&	Maximum depth in the Restricted\\
					 						&									&   Vertical Habitat Range Model.\\
		\texttt{depth\_off\_bottom}*		& 	Preferred animal habitat depth.	&   Preferred depth in the Habitat\\
					 						&									&   Preference Model.\\
		\texttt{depth\_off\_bottom\_sd}*	& 	SD of preferred depth.			&   Standard Deviation of preferred\\
					 						&									&   depth in the Habitat Preference Model.\\
	\end{tabular}
	\caption{A summary of the \texttt{params} key-value pairs used in Animal Modeling module.  \newline * optional parameters.
		\label{animalParams}}
\end{table}

\subsubsection{Goodness Computation}
goodnessGridFun (grids, params, debug=FALSE, silent=FALSE) 
Goodness computation (Section~\ref{evaluationOfReceierEmplacements}) is handled by the \texttt{goodnessGridFun()}, which takes in \texttt{params}, a parameter dictionary, and \texttt{grids}, a dictionary containing the Bathymetry Grid, and Behavior Grid.  The \texttt{bias} value is used to tell the module which sub-function should be used to compute Goodness.  All necessary parameters for the chosen sub-function are passed in via the \texttt{params} dictionary.  The module is responsible for adding the GoodnessGrid to the $grids$ dictionary.  Unlike the Animal Population and Bathymetric parsing modules, this module does not directly return a Grid object, but inserts it into the \texttt{grids} dictionary.  This behavior reflects the idea that the Goodness is logically dependent upon bathymetry and animal behavior.  Furthermore, this behavior is intended to guide users towards creating a Bathymetry and Behavior Grid before generating a GoodnessGrid.

Because the Goodness computation can take a substantial amount of time, sub-functions which compute Goodness should inform users what percentage of the computation has been completed.  The \texttt{silent} parameter is a boolean that disables this update when set to True.  A \texttt{debug} boolean is also available to toggle debug printing.

\subsubsection{Suppression}
suppressionFun = function(loc, grids, params, debug=FALSE)
Suppression (Section~\ref{suppression}) operations are handled by the \texttt{suppressionFun} function, which takes in \texttt{params}, a parameter dictionary, \texttt{grids}, a dictionary containing the Goodness, Bathymetry, and Behavior Grids, \texttt{loc}, and a dictionary mapping the keys 'r' and 'c' to the row and column indexes of the cell to be suppressed.  The module is responsible for reducing the values around an area, given by \texttt{loc}, on the GoodnessGrid and returning the suppressed GoodnessGrid.  The method in which suppression is applied is given by the \texttt{suppressionFcn} value in \texttt{params}.  The dimensions of the square area affected by suppression is given by \texttt{suppressionRange}.  Section~\ref{suppressionAlgorithms} describes how \texttt{minsuppressionValue}, \texttt{maxsuppressionValue}, and \texttt{shapeFcn} can be used to define a suppression template or gradient.  A \texttt{debug} boolean is also available to toggle debug printing.

Recalling that the process of placing a sensor location and suppressing it is an iterative process, it is worth noting that the suppression module is only responsible for performing one suppression operation (that of the target \texttt{loc}).  



TODO: how is debug variable explained?  uniform across dispatchers?

\begin{table}[ht]
	\begin{tabular}{l l l}
		Key									&	Value 							&	Description\\
		\hline
		\texttt{suppressionFcn}				& 	Suppression Function Name.		&	The name of the suppression \\

		\texttt{suppressionRange}			&	Distance from loc to suppress.	&	How far (in cells) out from loc\\
											&									&   to suppress.\\
		\texttt{sensorElevation}			& 	Elevation off sea floor.		&   Sensor elevation (in meters) off the see floor.\\
		\texttt{minsuppressionValue}*		& 	Min suppression multiplier.		&	Minimum penalizing coefficient.\\
		\texttt{maxsuppressionValue}*		& 	Max suppression multiplier.		&	maximum penalizing coefficient.\\
		\texttt{shapeFcn}*					&   Distribution Function ID. 		&   Name of the statistical distribution\\
											&									&   model to use.\\
	\end{tabular}
	\caption{A summary of the \texttt{params} key-value pairs used in the Suppression module.  \newline * optional parameters.
		\label{animalParams}}
\end{table}

\subsubsection{Sensor Placement}
sensorFun(grids,params, debug=FALSE, silent = FALSE)
As mentioned in Section\ref{heuristics}, a tight coupling exists between the heuristic and Evaluation Algorithms.  The sample application provided is very basic, utilizing a brute-force goodness computation on all cells in a the study area, and an exhaustive search to identify potential candidates for sensor placement.  Also recall that the selection of sensor placements and suppression are an iterative process.  To satisfy both of these relationships, the three operations are combined into a larger function \texttt{sensorFun}.  This function handles goodness computation, the selection of sensor locations, and the suppression of those locations.  It is important to not that while this function is important and warrants mention, it is not an extensible module.  That is to say, it is merely a driver function that binds together three independent modules (Goodness Computation, Sensor Placement and Suppression), handling the (minimal) dependencies between each.  Modifying the nature in which sensors placements are selected or chosen for consideration will require a different driver.  The \textttt{sensorFun} function takes in \texttt{grids}, a dictionary containing the Bathymetry and Behavior Grids and a parameter dictionary, \texttt{params}.  The function also provides two flags, \texttt{debug}, which toggles debug printing, and \texttt{silent}, which minimizes textual output from itself and the functions it calls.


\subsubsection{Sample Application}
To provide a demonstration of the framework, a simple, cohesive application, \texttt{acousticRun}, is provided.  The application makes use of framework functions to validate parameters, construct Bathymetry, define Behavior, compute Goodness, and choose optimal sensor locations with suppression.  

acousticRun <- function(params, showPlots=FALSE, debug=FALSE, save.inter=FALSE, silent=FALSE, multi=FALSE) {

custom test
acousticTest <- function(bias=3, real=FALSE, exact=FALSE, multi=FALSE, showPlots=FALSE, paper=FALSE, silent=FALSE, debug=FALSE) {
	Executes a test run of the program, using default parameters.  No additional 
	parameters are necessary. The code for this function can be used as a template for new projects.


* Intended to be used as a loose R framework, where users define new sub functions and add them to the dispatcher functions.
* dispatcher functions
* Provided implementation is very simple.
* parameters are very loose, allowing for easy implementation. makes it more flexible but less neat and concise and error prone.

\subsubsection{Web Server}
\label{webServer}
Included alongside the framework is a web-application (webapp) with a Graphical User Interface (GUI) that runs a simple demonstrative (demo) application using the framework.  The $Rook$ R package is used to handle HTTP interactions between the GUI and the R demo application.  The GUI is a simple HTML page that generates a list of parameters (including a unique $timestamp$ identifier) based on user input, creates a JSON (JavaScript Object Notation) string, and sends an HTTP request to the Rook server with that JSON string.  Using the $rjson$ library, the Rook server decodes the JSON string into R data objects, and calls the demo application using the decoded parameters.  The Rook application signals the successful reception and decoding of the JSON string as an HTTP 200 status update.  The GUI then begins waiting for the completion of the simulation (which may take some time) by continuously checking (ignoring failures) for the existence of a text document (named for the unique $timestamp$ identifier) on the server.  When the simulation finishes its execution (either via error or normal completion), it writes its several output files (Section~\ref{outputFiles}), and a text document containing the JSON representation of the outputs (file paths to graphics and a dictionary of results).  All output files are tagged with a unique $timestamp$ identifier.  Once the GUI finds an output file with the correct $timestamp$ signature, it reads the file, parses the results, and displays them within an HTML page.  If the local system supports it, a zip file of all result files is also supplied.  The webapp serves to simplify the selection and specification of parameters to the demo application.  This allows users to more easily understand the utility of the framework and application.

//TODO talk about how users interact with the webapp

\subsection{Implementation Hurdles}
\subsubsection{Complexity and Usability}
The primary trade-off that occurs with any application is that between simplicity and control.  While a simpler, less-detailed application may lower the effort required, it inevitably reduces the level of control a users has over the application.  A significant number of variables and options may serve to increase control over an application, but also require increased time and effort to understand and use effectively.  Put simply, very specific actions require very detailed instruction, which in turn requires significant effort.  On the other hand, simpler applications may be more easily understood and adopted, but ultimately lack higher levels of control.  To address this trade-off, both a demo application (Section~\ref{webServer}) and framework are provided.  The demo application provides an easy-to-use application that works "out-of-the-box" and has a useful subset of features, while the framework provides access to more detailed functionalities for advanced users.

\subsubsection{Coordinate Conversion}
As mentioned in Section~\ref{bathymetricGrid}, bathymetric files are composed of a regular grid of cells.  However, because the Earth is a 3D sphere, translation is necessary to map that 3D sphere to a 2D grid.  This translation introduces potential error into the specification of a study site.  One such source of error occurs when the method of translation is not specified, leading to ambiguity in how grid cells should be read.  Another possible source of error can be attributed to rounding errors in the number of degrees latitude and longitude represented by each cell.  In grids spanning hundreds of thousands of cells, small rounding errors can lead to large positional discrepancies.  To deal with these issues, the framework requires users to specify their study site as grid cell indexes.  This puts the burden of translating latitude and longitude into gird coordinates on the user (who likely knows best how to handle their data).  Additionally, final receiver placements are given in terms of global (relative to the input bathymetric file) and local (relative to the defined study site) indexes.  This facilitates error checking and helps to identify translational errors.  

\subsubsection{Rook}
The $Rook$ package was selected as a webserver because it offered support for cloud-based web hosting on Heroku and Amazon Web Services (AWS).  This feature was desirable as it allowed users to quickly create a working instance of our web application without modification to their local computers.  Unfortunately, the $Rook$ webserver is implemented using a single, blocking thread.  This means that $Rook$ is only able to handle one request at a time, and will wait for a request to complete before accepting any other other requests.  Because the same Rook thread that receives a request must also call the demo application (which takes about 30 seconds to complete), the entire webserver is unresponsive to new requests until the demo application completes its execution.  This unresponsiveness can lead users to feel like the application is "frozen" or "broken".  To solve this problem, a loading icon (spinning circle) is used to assure users that the webapp is working.  Another issue with the $Rook$ package is that it imposes a 250 character limit on the length of POST requst data.  Because of the substantial number of parameters sent to the demo application, POST data strings are often very long ($\ge$500 characters).  To compensate, POST data from the HTML page must to be cut into shorter segments and sent with sequential identifiers and re-assembled on the server.
